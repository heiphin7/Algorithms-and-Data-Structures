package AdvancedProblems;

public class HouseRobber {

    /*
        by @heiphin7

        Задача 198 из leetcode

        Определить максимальную сумму, которую можно украсть, не обворовывая два соседних дома.
        То есть подобрать такую сумму, чтобы все ее элементы не были соседями друг у друга

        Алгоритм работает за O (N) и потребляет O (N) памяти
    */

    public static int rob(int[] houses) {
        if (houses.length == 0) return 0;
        if (houses.length == 1) return houses[0];

        // Новый массив dp, в котором мы будем хранить максимальные возможные числа
        int[] dp = new int[houses.length];

        /*
        * Первый элемент в новом массиве - первый в старом
        * А второй элемент это уже максимальные элемент из первого и второго числа в старом массиве
        */

        dp[0] = houses[0];
        dp[1] = Math.max(houses[0], houses[1]);


        for(int i = 2; i < houses.length; i++) {
            /*
            * Самая важная строка во всем алгоритме. Здесь мы и решаем грабить дом или нет
            * dp[i-1] означает что мы не будем грабить дом и продолжаем подбирать элементы, и выбираем текущий максимум
            * dp[i-2] + houses[i] означает что мы подбираем один из элементов, то есть текущий элемет с i-2 элеметом
            */
            dp[i] = Math.max(dp[i-1], dp[i-2] + houses[i]);
        }

        // так как последний элемент в массиве - всегда максимальная, просто возвращаем последний элемент из массива
        return dp[dp.length-1];
    }
}
